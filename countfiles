#!/usr/bin/perl -w
use File::Find;
use Pod::Usage;
use Getopt::Long;
&Getopt::Long::config("no_ignore_case");

=head1 NAME

count_files.pl - A tool for summarizing inode usage within a directory

=head1 SYNOPSIS

    count_files.pl 
     - summarizes the current directory

    -- or --

    count_files.pl <<directory_to_search>>
    - summarizes the given directory

    -- or --

    count_files.pl --help
    count_files.pl --man
    - prints out help and man pages

=head1 DESCRIPTION

This script provides a simple way to summarize file usage for a given directory.  
Why is this important?  Well, you probably got here because you are over your 
"files" quota and need help in clearing out unused/uneeded files.  
While there are good tools for determine disk space usage there were not (until now) 
any for determining file usage.

Run this tool from within your home directory to get a listing of your 10 
directories with the most files.  You can then tar or delete unused/uneeded files 
and directories until you are under quota.  As always be careful when deleting 
files from your directory.

=head1 COMMAND LINE OPTIONS

=over

=item B<-h, --help>

Display a program usage screen and exit.

=item B<-m, --man>

Displays this page.

=back

=head1 EXAMPLES

    count_files.pl 
    - gives an file summary for the current working directory

    count_files.pl public_html 
    - gives an file summary for the public_html directory

=head1 REQUIREMENTS

    [core]
    File::Find: The meat and potatoes of this script
    Getopt::Long: Handles argument parsing
    Pod::Usage: Prints out this great message

=head1 TODO

    1) ignore requests for additional features
    2) drink beer

=head1 AUTHOR

Richard Kip (kip@cs.ucsb.edu)

=cut

#
# Configuration Options
#
my $Man;
my $Help;
GetOptions( 'man'   => \$Man,
            'help'  => \$Help
) or pod2usage("\nSyntax error.\n\n");

#
# Handle Some Error Conditions
#
if ($Help) {
    pod2usage(1);
} elsif ($Man) {
    pod2usage(-verbose => 2);
}

# don't accept multiple arguments
if ($#ARGV > 0) { pod2usage("\nSyntax Error: You can only specify one directory at a time\n\n"); }

print "\nSearching: ";
# If no argument given, default to current working directory
if (!$ARGV[0]) {
    $ARGV[0] = '.';
    print "current directory";
} else {
    print $ARGV[0];
}
print " (this might take a few minutes)...\n\n";

# Catch nonexistant or non-directory arguments here (note: this just gives a prettier error msg)
unless ((-e $ARGV[0]) && (-d $ARGV[0])) { pod2usage("\nError: $ARGV[0] must be a directory\n\n"); }

# append a '/' to file path if it does not exist
unless ($ARGV[0] =~ /\/$/) { $ARGV[0] = $ARGV[0] . '/'; }

#
# Start recursing through directories and counting indoes
#
my $counter = {};       # for holding directoy name and count
find(\&count, @ARGV);   # does all the work File::Find invokes counter sub on passed arguments

my $total_inodes    = 0; # The count of all inodes in the given directory
my $directory_count = 0; # Counter for keeping track of how many dirs we've listed
my $directory_limit = 10;# The maximum number of direcotries to print out

# print header
print "Files\tDirectory\n";
print "_____\t_________\n";

# Loop though the list of directories generated by the find subroutine
# but first sort the list by the number of files with the biggest directories first
foreach my $key (reverse(sort { $counter->{$a} <=> $counter->{$b} } keys %$counter)) {
    $directory_count++;
    if ($directory_count <= $directory_limit) {
        # print inode count and directory/file name
        print "$counter->{$key}\t$key\n";
    }
    $total_inodes += $counter->{$key};
}
print "-------------------------------------\n";
print "$total_inodes\tin entire directory\n\n";
print "Use count_files.pl --man for more information\n\n";

sub count
# recurses through directory tree counting the number of inodes and 
# adding that count to a list of the top level direcories.
{
    # get the name of current file
    $file = $File::Find::name;
    # Remove './' from file name (if it is there)
    $file =~ s/^\.\///;
    # remove the "base" directory from the file path
    unless ($ARGV[0] eq '.') { $file =~ s/^$ARGV[0]//; }
    my @full_path = split/\//,$file;
    # only count directories directly below the main directory
    $counter->{$full_path[0]}++;
}
